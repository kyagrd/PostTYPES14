{-# LANGUAGE GADTs, RankNTypes, TypeOperators, FlexibleInstances #-}
module Rec2 where

type a .-> b = forall i. a i -> b i

data Mu_0 f    = In_0 (f (Mu_0 f) (Mu_0 f))
data Mu_1 f i  = In_1 (f (Mu_1 f) (Mu_1 f) i)
-- primitive recursion
                           {- cast -}         {- call -}
type Phi_0 f a = forall r. (r  -> Mu_0 f)  -> (r  -> a)  -> f r r  -> a
type Phi_1 f a = forall r. (r .-> Mu_1 f)  -> (r .-> a)  -> f r r .-> a

mpr0 :: Phi_0 f a -> Mu_0 f  -> a
mpr0 phi (In_0 x) = phi id (mpr0 phi) x

mpr1 :: Phi_1 f a -> Mu_1 f .-> a
mpr1 phi (In_1 x) = phi id (mpr1 phi) x


data Void

data MuC_0 f    = InC_0 (f Void (MuC_0 f))
data MuC_1 f i  = InC_1 (f Void (MuC_1 f) i)

-- course-of-values recursion
                            {- out -}            {- cast -}          {- call -}
type PhiC_0 f a = forall r. (r  -> f Void r)  -> (r  -> MuC_0 f)  -> (r  -> a)  -> f Void r  -> a
type PhiC_1 f a = forall r. (r .-> f Void r)  -> (r .-> MuC_1 f)  -> (r .-> a)  -> f Void r .-> a

unInC_0 (InC_0 x) = x
unInC_1 (InC_1 x) = x

mcvpr0 :: PhiC_0 f a -> MuC_0 f  -> a
mcvpr0 phi (InC_0 x) = phi unInC_0 id (mcvpr0 phi) x

mcvpr1 :: PhiC_1 f a -> MuC_1 f .-> a
mcvpr1 phi (InC_1 x) = phi unInC_1 id (mcvpr1 phi) x



data MuP_0 f a    = InP_0 (f a (MuP_0 f a))    | Var_0 a
data MuP_1 f a i  = InP_1 (f a (MuP_1 f a) i)  | Var_1 (a i)

-- iteration over PHOAS
                            {- call -}
type PhiP_0 f a = forall r. (r a  -> a) -> f a (r a)  -> a
type PhiP_1 f a = forall r. (r a .-> a) -> f a (r a) .-> a

mphit0 :: PhiP_0 f a -> (forall a. MuP_0 f a) -> a 
mphit0 phi x = mphit phi x where
  mphit phi (InP_0 x) = phi (mphit phi) x
  mphit phi (Var_0 a) = a

mphit1 :: PhiP_1 f a -> (forall a. MuP_1 f a i) -> a i
mphit1 phi x = mphit phi x where
  mphit :: PhiP_1 f a -> MuP_1 f a .-> a
  mphit phi (InP_1 x) = phi (mphit phi) x
  mphit phi (Var_1 a) = a


-- course-of-values iteration over PHOAS
                             {- out -}              {- call -}
type PhiPC_0 f a = forall r. (r a  -> f a (r a)) -> (r a  -> a) -> f a (r a)  -> a
type PhiPC_1 f a = forall r. (r a .-> f a (r a)) -> (r a .-> a) -> f a (r a) .-> a

unInP_0 (InP_0 x) = x
unInP_1 (InP_1 x) = x

mphcv0 :: PhiPC_0 f a -> (forall a. MuP_0 f a) -> a
mphcv0 phi x = mphcv phi x where
  mphcv :: PhiPC_0 f a -> MuP_0 f a -> a
  mphcv phi (InP_0 x) = phi unInP_0 (mphcv phi) x
  mphcv phi (Var_0 a) = a

mphcv1 :: PhiPC_1 f a -> (forall a. MuP_1 f a i) -> a i
mphcv1 phi x = mphcv phi x where
  mphcv :: PhiPC_1 f a -> MuP_1 f a .-> a
  mphcv phi (InP_1 x) = phi unInP_1 (mphcv phi) x
  mphcv phi (Var_1 a) = a




class Functor2nd f where
  fmap2nd :: (a -> b) -> f x a -> f x b

-- Functor2nd instance isn't very useful though because
-- it is an incorherent overlapping instances with other
-- functor instances such as ((,) a) or ((->) r).
instance Functor2nd f => Functor (f a) where
  fmap f = fmap2nd f

class Functor2nd f => Positive f where
  lemmPositive :: f x r -> f y r

-- cousre-of-values recursion fixpoint to primitive recursion fixpoint
muc2mu :: Positive f => MuC_0 f -> Mu_0 f
muc2mu x = mcvpr0 phi x where
  phi out cast call v = In_0 $ lemmPositive $ fmap2nd call v

-- primitive recursion fixpoint to cousre-of-values recursion fixpoint
mu2muc :: Positive f => Mu_0 f -> MuC_0 f
mu2muc x = mpr0 phi x where
  phi cast call v = InC_0 $ lemmPositive $ fmap2nd call v

-- cousre-of-values recursion fixpoint to PHOAS fixpoint
muc2mup :: Positive f => MuC_0 f -> MuP_0 f a
muc2mup x = mcvpr0 phi x where
  phi out cast call v = InP_0 $ lemmPositive $ fmap2nd call v

-- PHOAS fixpoint to course-of-values recursion fixpoint
mup2muc :: Positive f => (forall a.MuP_0 f a) -> MuC_0 f
mup2muc x = mphit0 phi x where
  phi call v = InC_0 $ lemmPositive $ fmap2nd call v

-- PHOAS fixpoint to primitive recursion fixpoint
mup2mu :: Functor2nd f => (forall a.MuP_0 f a) -> Mu_0 f
mup2mu x = mphit0 phi x where
  phi call v = In_0 $ fmap2nd call v

-- primitive recursion fixpoint to PHOAS fixpoint
mu2mup :: Positive f => Mu_0 f -> MuP_0 f a
mu2mup x = mpr0 phi x where
  phi cast call v = InP_0 $ lemmPositive $ fmap2nd call v




{- ---------------------------
data MuC_0 f    = InC_0 (forall z. f z (MuC_0 f))
data MuC_1 f i  = InC_1 (forall z. f z (MuC_1 f) i)

type PhiC_0 f a = forall r    .(           r    -> (forall z.f z (MuC_0 f)))    -> (r  -> MuC_0 f) -> (r  -> a) -> (forall z. f z r)   -> a
type PhiC_1 f a = forall r i  .(forall i.  r i  -> (forall z.f z (MuC_1 f) i))  -> (r .-> MuC_1 f) -> (r .-> a) -> (forall z. f z r i) -> a i
--------------------------- -}


data E r_ r = App r r | Lam (r_ -> r) | Let r (r_ ->r)
type Exp' a = MuP_0 E a
type Exp = forall a. Exp' a
lam f = InP_0 (Lam (f . Var_0))
app e1 e2 = InP_0 (App e1 e2)
let_ e f = InP_0 (Let e (f . Var_0))

vars = [ [i] | i <- ['a'..'z'] ] ++ [ i:show j | j<-[1..], i<-['a'..'z'] ]

myexp = let_ (lam(\f -> (lam(\x -> app f (app f x)))))
             (\twice -> app twice twice)

showExp :: Exp -> String
showExp e = mphit0 phi e vars where
  phi sh (App e1 e2) = \vs     -> "("++sh e1 vs++" "++sh e2 vs++")"
  phi sh (Lam f)     = \(v:vs) -> "(\\"++v++"."
                                       ++sh(f(const v)) vs++")"
  phi sh (Let e f)   = \(v:vs) -> "(let "++v++"="++sh e vs++" in "
                                            ++sh(f(const v)) vs++")"

desugar :: Exp -> Exp
desugar = mphit0 phi where
  phi desug (App e1 e2) = app (desug e1) (desug e2)
  phi desug (Lam f)     = lam (desug . f)
  phi desug (Let e f)   = lam (desug . f) `app` (desug e)


reduce :: Exp -> Exp
reduce = mphit0 phi where
  phi red (App e1 e2) = app (red e1) (red e2)
--  phi red (Lam f)     = lam (red . f)
  phi red (Let e f)   = f (red e)



